<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Noah&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Noah's Blog">
<meta property="og:url" content="http://noahli.com/index.html">
<meta property="og:site_name" content="Noah's Blog">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Noah's Blog">
<meta name="twitter:description">
  
    <link rel="alternate" href="/atom.xml" title="Noah&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Noah&#39;s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="Flux RSS"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Rechercher"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://noahli.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Swift-Tutorial-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/06/28/Swift-Tutorial-1/" class="article-date">
  <time datetime="2016-06-28T01:43:40.000Z" itemprop="datePublished">2016-06-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/28/Swift-Tutorial-1/">Swift 基础知识</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Swift-简介"><a href="#Swift-简介" class="headerlink" title="Swift 简介"></a>Swift 简介</h2><p>这是Swift入门系列，比较适合已经掌握一两门语言之后，想要学习Swift的人参考。<br>另外这个系列会专注于理论的东西。不会跟工具结合起来。希望达到的目的是能够看完之后就可以看懂大部分使用Swift写的代码。所以其实最适合的是从Object-C转Swift的开发者。</p>
<p>先贴上一段官网对Swift的介绍</p>
<p>Swift is a powerful and intuitive programming language for macOS, iOS, watchOS and tvOS. Writing Swift code is interactive and fun, the syntax is concise yet expressive, and Swift includes modern features developers love. Swift code is safe by design, yet also produces software that runs lightning-fast.</p>
<p>我总结就是简单，安全，快。</p>
<p>使用Object-C开发App已经两年了。其实很容易感觉到Object-C这种语言有相当多的缺点。其中感觉最明显的一点就是函数的命名问题。用Object-C的函数名字太长了，看起来非常地冗余。经常会出现一些函数命名是需要多行来显示的。Swift的语法比Object-C简洁了非常多。并且借鉴了许多其它语言的优点，加入了大量的语法糖。学习起来会觉得比较有趣。</p>
<p>关于安全。我现在能体会到Swift比较安全的只有一点，那就是舍弃了null而使用Optional语法。Optional在理解Swift语法中是非常重要的，在之后会详细地说明。</p>
<h2 id="基础语法与特性"><a href="#基础语法与特性" class="headerlink" title="基础语法与特性"></a>基础语法与特性</h2><h4 id="变量与常量"><a href="#变量与常量" class="headerlink" title="变量与常量"></a>变量与常量</h4><p>使用var声明变量，使用let声明常量。<br>如果如下尝试改变用let声明的变量，编译器就会报错：<strong>“Cannot assign value: ‘str’ is a ‘let’ constant</strong></p>
<pre><code>let str = &quot;String&quot;
str = &quot;String 2&quot;
</code></pre><h4 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h4><p>看到上面的变量声明之后，你可能会觉得Swift和JavaScript一样是一种弱类型的语言。但其实Swift是强类型的语言。上面的变量声明还可以是这样：</p>
<pre><code>let str: String = “String”
</code></pre><p>其中String就是变量的类型。上面的:String 之所以可以省略是因为后面给变量str赋值了一个String类型的常量。所以编译器能够推断出str也是String类型的。</p>
<h4 id="类和函数"><a href="#类和函数" class="headerlink" title="类和函数"></a>类和函数</h4><pre><code>class FirstClass{
    let total : Double
    let pro : String

    init(total: Double, pro :String) {
        self.total = total
        self.pro = pro
    }

    func doSomeThing(param1: String, param2: String) -&gt; String{
        print(&quot;do something \(str)&quot;)
        return &quot;over&quot;
    }
}

var fc = FirstClass(total: 24,pro: &quot;sddf&quot;)
fc.doSomeThing(param1: &quot;Hello&quot;,param2: &quot;World&quot;)
</code></pre><p>从上面的代码可以看到类和函数是如何定义和使用的。需要注意的是init方法是每个类的构造函数。不需要前缀func。 函数的返回值用-&gt; 表示，这个和ES6里面的箭头函数是一样的。另外一个和其它编程语言不同的是，在使用函数的时候，需要把参数的名字也加上。如例子中的param1和param2。不过对于这些简单常见的错误，编译器都能够检测出来并且给出推荐如何修改。这是对Swift初学者来说比较好的一件事情。</p>
<p>上面的代码中还有一段打印的函数：</p>
<pre><code>print(&quot;do something \(str)&quot;)
</code></pre><p>这里示范了如何在控制台打印字符以及如何在字符中包含参数（使用反斜杠加括号）。</p>
<h4 id="数组和字典"><a href="#数组和字典" class="headerlink" title="数组和字典"></a>数组和字典</h4><p>先看数组的使用方法：</p>
<pre><code>let arr = [2.0, 4.5, 3.7]
let arrExplicit: [Double]

for i in 0..&lt;arr.count{
    print(arr[i])
}
</code></pre><p>这里有几点要注意的：</p>
<ol>
<li>数组常量的使用只需要用中括号里面加数组的元素；</li>
<li>显式的声明一个数组变量，则变量的类型为中括号，里面是每个元素的类型；</li>
<li>for循环的条件不需要用括号括起来；</li>
<li>0..&lt;3 表示0到3的一个数组，但不包括3。 0…3会包括3。</li>
</ol>
<p>数组的一些API，见文知意：</p>
<pre><code>arr.append(6.3)
arr.remove(at: 3)
arr.insert(10.9, at: 1)
arr.append(contentsOf: [3.5,6.8])
arr[0] = 89.23
arr.reversed()
arr.sort()
</code></pre><p>字典的显示声明：</p>
<pre><code>var dictionary: [String:Int] = [
    &quot;one&quot; : 1,
    &quot;two&quot; : 2,
    &quot;three&quot; : 3
]
</code></pre><p>赋值一个空的字典：</p>
<pre><code>var emptyDictionary: [Int:Int] = [:]
</code></pre><p>字典取值：</p>
<pre><code>let value = dictionary[&quot;one&quot;]
</code></pre><p>字典的添加,更新和删除</p>
<pre><code>var emptyDictionary: [Int:Int] = [:]
emptyDictionary[1] = 12
emptyDictionary.updateValue(14, forKey: 1)
emptyDictionary.removeValue(forKey: 1)
</code></pre><p>另外需要注意的是，在Swift中，Array和Dictionary是值类型的。所以使用简单的等号就可以完成拷贝了。不像有些语言还分深拷贝和浅拷贝。</p>
<p>可见数组与字典的使用都是相当简洁的。</p>
<h4 id="元组（Tuple）"><a href="#元组（Tuple）" class="headerlink" title="元组（Tuple）"></a>元组（Tuple）</h4><p>A tuple is a group of zero or more values represented as one value.</p>
<p>看看代码大概就知道Tuple是什么了：</p>
<pre><code>var tuple  = (&quot;name&quot;,12)
var namedTuple = (name:&quot;Name&quot;,age:12)
namedTuple.name = &quot;updateName&quot;
</code></pre><p>其实元组就是一种数据结构，里面包含一个或多个值，并且这些值可以是不同类型的。元组中的值可以是命名的也可以是匿名的。如果是命名的，那么可以使用.符号来获取该值。<br>那么为什么要有元组这种数据结构呢？<br>可以看下以下的代码：</p>
<pre><code>func getNameAndAge() -&gt; (String,Int){
    return (&quot;Ace&quot;,20)
}
</code></pre><p>在有些情况下我们会需要一个函数有多个返回值，此时Tuple就非常有用了。</p>
<h4 id="枚举类型（Enum）"><a href="#枚举类型（Enum）" class="headerlink" title="枚举类型（Enum）"></a>枚举类型（Enum）</h4><p>声明与使用：</p>
<pre><code>enum iOSDeviceType {
    case iPhone
    case iPad
    case iWatch
}

var myDevice = iOSDeviceType.iPhone
</code></pre><p>当变量的类型已经明确时，赋值可以简化为：</p>
<pre><code>var myDevice: iOSDeviceType
myDevice = .iPhone    
</code></pre><p>raw value<br>每个枚举都可以拥有自己的一个原生类型的raw value，所有的枚举关联的raw value必须是同一个类型的。当类型是Int时，默认按照枚举值的顺序递增其raw value。</p>
<pre><code>enum Direction: Int {
    case Up = 1
    case Down // will have the raw value 2
    case Left // will have the raw value 3
    case Right // will have the raw value 4
}
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://noahli.com/2016/06/28/Swift-Tutorial-1/" data-id="ciqx6qntr0000nrkaaa4jb0df" class="article-share-link">Partager</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Swift/">Swift</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-iOS-Core-Location" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/18/iOS-Core-Location/" class="article-date">
  <time datetime="2016-04-18T07:47:54.000Z" itemprop="datePublished">2016-04-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/18/iOS-Core-Location/">iOS定位服务</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>最近在做公司内部的一个项目。主要需求很简单，就是每隔N分钟向服务器发送设备的位置，不管此时App是运行在前台还是后台。<br>这里总结一下使用iOS定位服务的一些关键点和需要注意的地方。</p>
<h2 id="App-的设置"><a href="#App-的设置" class="headerlink" title="App 的设置"></a>App 的设置</h2><ol>
<li>因为App需要在后台的时候也能不断地获取设备的位置。所以要将Capablities里面的BackgroundMode 设置成Enable。并且勾选其中的Location updates选项。</li>
<li>在iOS8以后，需要在info.plist里面添加NSLocationAlwaysUsageDescription或者NSLocationWhenInUseUsageDescription,这两个key都是NSString类型。使用哪个（或者两者都添加）取决于申请定位的权限，这个下文会提到。这个所谓的描述就是当系统提示用户App要使用定位的时候，会加在系统提示的后面，如图。</li>
</ol>
<h2 id="初始化CLLocationManager"><a href="#初始化CLLocationManager" class="headerlink" title="初始化CLLocationManager"></a>初始化CLLocationManager</h2><p>使用iOS定位服务需要引入系统的头文件并且实现CLLocationManagerDelegate的代理。</p>
<pre><code>#import &lt;CoreLocation/CoreLocation.h&gt;
</code></pre><p>先来看一下初始化的代码：</p>
<pre><code>-(void) createLocationManager{
    _locationManager = [[CLLocationManager alloc] init];
    _locationManager.delegate = self;
    if ([_locationManager respondsToSelector:@selector(requestAlwaysAuthorization)]) {
        [_locationManager requestAlwaysAuthorization];
    }
    if ([_locationManager respondsToSelector:@selector(setAllowsBackgroundLocationUpdates:)]) {
        [_locationManager setAllowsBackgroundLocationUpdates:YES];
    }
    _locationManager.pausesLocationUpdatesAutomatically = NO;
}
</code></pre><p>iOS8以后，系统的定位权限有三种，对应设置里面的总是，永不，和App使用期间。那么根据我们App的需求，我们需要申请“总是”这种权限。相应地，我们要在info.plist里面添加的是NSLocationAlwaysUsageDescription。</p>
<pre><code>if ([_locationManager respondsToSelector:@selector(requestAlwaysAuthorization)]) {
    [_locationManager requestAlwaysAuthorization];
}
</code></pre><p>并且在iOS9之后，如果需要在后台保持定位,除了上文所说的在App的setting和info文件里面设置以外，还需要加上下面的代码：</p>
<pre><code>if ([_locationManager respondsToSelector:@selector(setAllowsBackgroundLocationUpdates:)]) {
    [_locationManager setAllowsBackgroundLocationUpdates:YES];
}
</code></pre><p>整个初始化完成以后，调用以下API系统就会开始定位了</p>
<pre><code>[_locationManager startUpdatingLocation];
</code></pre><h2 id="在代理里面实现位置更新的代码"><a href="#在代理里面实现位置更新的代码" class="headerlink" title="在代理里面实现位置更新的代码"></a>在代理里面实现位置更新的代码</h2><p>正常来说，完成上面的所有设置，就可以使用iOS系统的定位服务了。<br>系统会每秒都调用</p>
<pre><code>-(void)locationManager:(CLLocationManager *)manager didUpdateLocations:(NSArray&lt;CLLocation *&gt; *)locations
</code></pre><p>这个代理方法，我们所要做的就是在这里处理系统返回回来的位置信息。<br>CLLocation这个类里面包括的一些常用的位置信息有经度、纬度、海拔、速度、精确度等等，根据项目的需求可以对其进行相应的处理。</p>
<p>到这里，最基础的部分已经完成。接下来会探讨一些别的配置。</p>
<h2 id="pausesLocationUpdatesAutomatically属性"><a href="#pausesLocationUpdatesAutomatically属性" class="headerlink" title="pausesLocationUpdatesAutomatically属性"></a>pausesLocationUpdatesAutomatically属性</h2><p>贴上一段官网对这个属性的描述：</p>
<p>Allowing the location manager to pause updates can improve battery life on the target device without sacrificing location data. When this property is set to YES, the location manager pauses updates (and powers down the appropriate hardware) at times when the location data is unlikely to change. For example, if the user stops for food while using a navigation app, the location manager might pause updates for a period of time. You can help the determination of when to pause location updates by assigning a value to the activityTypeproperty.</p>
<p>大致的意思就是如果这个属性设置成YES（默认的也是YES），那么系统会检测如果设备有一段时间没有移动，就会自动停掉位置更新服务。<strong>这里需要注意的是，一旦定位服务停止了，只有当用户再次开启App的时候定位服务才会重新启动。</strong><br>这里的一段时间是系统自动判定的，可以通过设置activityTypeproperty这个属性来决定这个时间的长短。<br>API的意思是，类似导航类的App,系统检验的时间会稍长一点，想运动类的App，就会比导航类的短一点。但是具体时间还是由系统来决定。</p>
<h2 id="DeferredUpdates"><a href="#DeferredUpdates" class="headerlink" title="DeferredUpdates"></a>DeferredUpdates</h2><p>默认地，定位服务的代理会每秒钟都更新一次位置，这样对电池的消耗量会特别地大。除了设置pausesLocationUpdatesAutomatically这个属性以外，iOS还提供了DeferredUpdates的机制。</p>
<p>官方API文档：</p>
<pre><code>- (void)allowDeferredLocationUpdatesUntilTraveled:(CLLocationDistance)distance
                                      timeout:(NSTimeInterval)timeout
</code></pre><p>distance：<br>    The distance (in meters) from the current location that must be travelled before event delivery resumes. To specify an unlimited distance, pass the CLLocationDistanceMaxconstant.</p>
<p>timeout：<br>    The amount of time (in seconds) from the current time that must pass before event delivery resumes. To specify an unlimited amount of time, pass the CLTimeIntervalMax constant.</p>
<p>就是你可以设置让系统每隔多远或者每隔多长时间更新一次位置。注意是“或”的关系，满足一个就会更新。<br>使用这个方法有很多要注意的地方：</p>
<ol>
<li>desiredAccuracy必须设置成kCLLocationAccuracyBest</li>
<li>distanceFilter必须设置成kCLErrorDeferredDistanceFiltered</li>
<li>必须能够使用GPS进行定位（而不仅仅是移动数据或者Wi-Fi）</li>
<li><strong>非常重要的一点，DeferredUpdates只会出现在设备进入低耗电量的状态，App运行在前台或者设备连接在Xcode上正在调试是不会触发的。（所以不可能在Debug的时候打印Log来检验，要调试的话，需要写一些Log存在本地的数据库）</strong></li>
</ol>
<p>官网的Example：</p>
<pre><code>-(void)locationManager:(CLLocationManager *)manager
didUpdateLocations:(NSArray *)locations {
  // Add the new locations to the hike
  [self.hike addLocations:locations];

  // Defer updates until the user hikes a certain distance or a period of time has passed
  if (!self.deferringUpdates) {
    CLLocationDistance distance = self.hike.goal - self.hike.distance;
    NSTimeInterval time = [self.nextUpdate timeIntervalSinceNow];
    [self.locationManager allowDeferredLocationUpdatesUntilTraveled:distance timeout:time];
    self.deferringUpdates = YES;
  } }

-(void)locationManager:(CLLocationManager *)manager
    didFinishDeferredUpdatesWithError:(NSError *)error {
  // Stop deferring updates
  self.deferringUpdates = NO;

  // Adjust for the next goal
}
</code></pre><h2 id="反地理编码"><a href="#反地理编码" class="headerlink" title="反地理编码"></a>反地理编码</h2><p>知道了经纬度，有时候我们需要获取这个经纬度对应的详细地址信息，示例如下：</p>
<pre><code>CLGeocoder *revGeo = [[CLGeocoder alloc] init];
  [revGeo reverseGeocodeLocation:location
                 completionHandler:^(NSArray *placemarks, NSError *error) {
                     if (!error &amp;&amp; [placemarks count] &gt; 0)
                     {
                         NSDictionary *dict =
                         [[placemarks objectAtIndex:0] addressDictionary];
                         NSArray *formattedLines = [dict objectForKey:@&quot;FormattedAddressLines&quot;];
                         NSString *formattedAddress = formattedLines[0];
                         NSLog(@&quot;address is %@&quot;,formattedAddress);
                     }else{
                         NSLog(@&quot;ERROR: %@&quot;, error);
                     }
                 }];
</code></pre><h2 id="关于坐标系的问题"><a href="#关于坐标系的问题" class="headerlink" title="关于坐标系的问题"></a>关于坐标系的问题</h2><p>最后讲一下关于坐标系的问题。<br>世界通用的坐标系是WGS坐标系，中国国测局的坐标系是GCJ，百度有自己的坐标系。<br>同样的经纬度应用在不同的坐标系会有所偏差，在Github上面有一个库可以实现不同坐标系之间的转化：<br><a href="https://github.com/TinyQ/TQLocationConverter" target="_blank" rel="external">https://github.com/TinyQ/TQLocationConverter</a><br>系统返回的自然是根据WGS定位的。如果使用百度SDK获取的就是Baidu坐标系的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://noahli.com/2016/04/18/iOS-Core-Location/" data-id="cin5tbuby0001ahka8yctlcop" class="article-share-link">Partager</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Swift-Currying" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/18/Swift-Currying/" class="article-date">
  <time datetime="2016-04-18T03:34:26.000Z" itemprop="datePublished">2016-04-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/18/Swift-Currying/">Swift中的函数柯里化</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本博客主要是对以下博客的翻译，加入一些自己对使用的理解和总结<br><a href="https://robots.thoughtbot.com/introduction-to-function-currying-in-swift" target="_blank" rel="external">https://robots.thoughtbot.com/introduction-to-function-currying-in-swift</a></p>
<p>什么是函数柯里化：<br>在计算机科学中，柯里化（Currying）是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数的技术。</p>
<p>概念很抽象，让我们从一个简单的例子开始逐步了解到底什么是函数柯里化。<br>我们有一个接受两个Int类型的参数的Add函数</p>
<pre><code>func add(a: Int, b: Int) -&gt; Int {
  return a + b
}
</code></pre><p>当我们调用这个函数时：</p>
<pre><code>let sum = add(2, 3) // sum = 5
</code></pre><p>现在有一个需求，我们要将一个整数集合里面的每一个元素都加2.<br>那么我们可以这样写</p>
<pre><code>let xs = 1...100
let x = xs.map { add($0, 2) } // x = [3, 4, 5, 6, etc]
</code></pre><p>这样写看起来还行。但是我总觉得很奇怪。因为我要为Add这个函数创建一个闭包。<br>如果我们只关注函数的类型，就会发现Add实际上是一个(Int,Int)-&gt;Int的函数。但是在这里，我们想要传给map函数的，实际上是一个(A)-&gt;B的函数。</p>
<p>所以，如果我们有一个(A)-&gt;B这样的函数，那么我们就不必传入一个闭包，而是直接传这个函数就好了。所以我们可以这样：</p>
<pre><code>func addTwo(a: Int) -&gt; Int {
  return add(a, 2)
}

let xs = 1...100
let x = xs.map(addTwo) // x = [3, 4, 5, 6, etc]
</code></pre><p>但是这个函数其实把“2”写死了。那如果我还要+3，+4…+100呢？<br>所以我们最好写一个比较通用的函数。</p>
<pre><code>func add(a: Int) -&gt; (Int -&gt; Int) {
  return { b in a + b }
}
</code></pre><p>那么我们现在可以这样子用了：</p>
<pre><code>let sum = add(2)(3) // sum = 5

let addTwo = add(2)
let xs = 1...100
let x = xs.map(addTwo) // x = [3, 4, 5, 6, etc]
</code></pre><p>这个看起来已经不错了，但是我们通过泛型可以让这个函数更加通用一点。</p>
<pre><code>func curry&lt;A, B, C&gt;(f: (A, B) -&gt; C) -&gt; (A -&gt; (B -&gt; C)) {
  return { a: A in
            { b: B in
              return f(a, b) // returns C
            }
         }
}
</code></pre><p>在Swift中，可以最终简化成这样：</p>
<pre><code>func curry&lt;A, B, C&gt;(f: (A, B) -&gt; C) -&gt; A -&gt; B -&gt; C {
  return { a in { b in f(a, b) } }
}
</code></pre><p>那么讲了那么多，这东西有什么用呢？<br>假设有这样一个需求，我需要记录某个系统的日志，日志需要包含以下几个要素：<br>操作人的名字name，时间time，日志类型type和日志内容msg。<br>一般可能会写这样的函数来调用：</p>
<pre><code>func createLogInfo(name:String, time:String, type:String, msg:String) -&gt;String{
    return &quot;name : \(name)\n&quot; + &quot;type : \(time)\n&quot; + (&quot;message : \(msg)\n&quot; +&quot;time: \(time)    &quot;)
}

let log = createLogInfo(&quot;Noah&quot;, time: &quot;today&quot;, type: &quot;Info&quot;, msg: &quot;Today&apos;s weather is good&quot;)
</code></pre><p>现在我觉得每次都要传那么多参数很麻烦，对于我自己写的日志，我希望有一个简单一点的方法：</p>
<pre><code>func createMyLogInfo(time:String, type:String, msg:String) -&gt;String{
    return createLogInfo(&quot;Noah&quot;, time: time, type: type, msg: msg)
}
</code></pre><p>我希望有一个只写Info类型日志的方法来简化操作：</p>
<pre><code>func createInfoLog(name:String, time:String, msg:String) -&gt;String{
    return createLogInfo(name, time: time, type: &quot;Info&quot;, msg: msg)
}
</code></pre><p>这样我每次都要写一个函数来简化我的操作。<br>如果使用柯里化：</p>
<pre><code>func curryFour&lt;A,B,C,D,E&gt;(f:(A,B,C,D)-&gt;E) -&gt;A-&gt;B-&gt;C-&gt;D-&gt;E{
    return {
        a in {b in {c in {d in f(a,b,c,d) }}}
    }
}
let curriedLogInfo = curryFour(createLogInfo)
curriedLogInfo(&quot;Noah&quot;)(&quot;Today&quot;)(&quot;Error&quot;)(&quot;SometingWrong&quot;)
let curriedMyLog = curriedLogInfo(&quot;Noah&quot;)
curriedMyLog(&quot;Tmr&quot;)(&quot;Info&quot;)(&quot;SomeInfo&quot;)
let curriedMyTodayLog = curriedLogInfo(&quot;Noah&quot;)(&quot;Today&quot;)
curriedMyTodayLog(&quot;Warining&quot;)(&quot;FBI&quot;)
</code></pre><p>总结：<br>现在我们重新再来看一下柯里化的定义：<br>在计算机科学中，柯里化（Currying）是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数的技术。</p>
<p>关键点就在于能够把函数作为参数，并且可以把函数作为返回值来使用。<br>所以函数柯里化实际上应该是“函数作为一等公民”这个特性所带来的附加的属性。就像数学里面能够从公理推导出定理一样。<br>函数柯里化的作用，我现在感受到的主要是能够方便地把一些通用的函数通过柯里化这种技术变得更加地适用某些特殊的场景。<br>相对地，反柯里化就是将函数变得拥有更强的普适性。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://noahli.com/2016/04/18/Swift-Currying/" data-id="cin5tbubt0000ahkacffjqjla" class="article-share-link">Partager</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Swift/">Swift</a></li></ul>

    </footer>
  </div>
  
</article>


  

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Mot-clés</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Swift/">Swift</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/iOS/">iOS</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Nuage de mot-clés</h3>
    <div class="widget tagcloud">
      <a href="/tags/Swift/" style="font-size: 20px;">Swift</a> <a href="/tags/iOS/" style="font-size: 10px;">iOS</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">April 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Articles récents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/06/28/Swift-Tutorial-1/">Swift 基础知识</a>
          </li>
        
          <li>
            <a href="/2016/04/18/iOS-Core-Location/">iOS定位服务</a>
          </li>
        
          <li>
            <a href="/2016/04/18/Swift-Currying/">Swift中的函数柯里化</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 Noah Li<br>
      Propulsé by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>
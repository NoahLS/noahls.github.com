<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Noah&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Noah's Blog">
<meta property="og:url" content="http://noahli.com/index.html">
<meta property="og:site_name" content="Noah's Blog">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Noah's Blog">
<meta name="twitter:description">
  
    <link rel="alternate" href="/atom.xml" title="Noah&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Noah&#39;s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://noahli.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-iOS-Core-Location" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/18/iOS-Core-Location/" class="article-date">
  <time datetime="2016-04-18T07:47:54.000Z" itemprop="datePublished">2016-04-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/18/iOS-Core-Location/">iOS定位服务</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>最近在做公司内部的一个项目。主要需求很简单，就是每隔N分钟向服务器发送设备的位置，不管此时App是运行在前台还是后台。<br>这里总结一下使用iOS定位服务的一些关键点和需要注意的地方。</p>
<h2 id="App-的设置"><a href="#App-的设置" class="headerlink" title="App 的设置"></a>App 的设置</h2><ol>
<li>因为App需要在后台的时候也能不断地获取设备的位置。所以要将Capablities里面的BackgroundMode 设置成Enable。并且勾选其中的Location updates选项。</li>
<li>在iOS8以后，需要在info.plist里面添加NSLocationAlwaysUsageDescription或者NSLocationWhenInUseUsageDescription,这两个key都是NSString类型。使用哪个（或者两者都添加）取决于申请定位的权限，这个下文会提到。这个所谓的描述就是当系统提示用户App要使用定位的时候，会加在系统提示的后面，如图。</li>
</ol>
<h2 id="初始化CLLocationManager"><a href="#初始化CLLocationManager" class="headerlink" title="初始化CLLocationManager"></a>初始化CLLocationManager</h2><p>使用iOS定位服务需要引入系统的头文件并且实现CLLocationManagerDelegate的代理。</p>
<pre><code>#import &lt;CoreLocation/CoreLocation.h&gt;
</code></pre><p>先来看一下初始化的代码：</p>
<pre><code>-(void) createLocationManager{
    _locationManager = [[CLLocationManager alloc] init];
    _locationManager.delegate = self;
    if ([_locationManager respondsToSelector:@selector(requestAlwaysAuthorization)]) {
        [_locationManager requestAlwaysAuthorization];
    }
    if ([_locationManager respondsToSelector:@selector(setAllowsBackgroundLocationUpdates:)]) {
        [_locationManager setAllowsBackgroundLocationUpdates:YES];
    }
    _locationManager.pausesLocationUpdatesAutomatically = NO;
}
</code></pre><p>iOS8以后，系统的定位权限有三种，对应设置里面的总是，永不，和App使用期间。那么根据我们App的需求，我们需要申请“总是”这种权限。相应地，我们要在info.plist里面添加的是NSLocationAlwaysUsageDescription。</p>
<pre><code>if ([_locationManager respondsToSelector:@selector(requestAlwaysAuthorization)]) {
    [_locationManager requestAlwaysAuthorization];
}
</code></pre><p>并且在iOS9之后，如果需要在后台保持定位,除了上文所说的在App的setting和info文件里面设置以外，还需要加上下面的代码：</p>
<pre><code>if ([_locationManager respondsToSelector:@selector(setAllowsBackgroundLocationUpdates:)]) {
    [_locationManager setAllowsBackgroundLocationUpdates:YES];
}
</code></pre><p>整个初始化完成以后，调用以下API系统就会开始定位了</p>
<pre><code>[_locationManager startUpdatingLocation];
</code></pre><h2 id="在代理里面实现位置更新的代码"><a href="#在代理里面实现位置更新的代码" class="headerlink" title="在代理里面实现位置更新的代码"></a>在代理里面实现位置更新的代码</h2><p>正常来说，完成上面的所有设置，就可以使用iOS系统的定位服务了。<br>系统会每秒都调用</p>
<pre><code>-(void)locationManager:(CLLocationManager *)manager didUpdateLocations:(NSArray&lt;CLLocation *&gt; *)locations
</code></pre><p>这个代理方法，我们所要做的就是在这里处理系统返回回来的位置信息。<br>CLLocation这个类里面包括的一些常用的位置信息有经度、纬度、海拔、速度、精确度等等，根据项目的需求可以对其进行相应的处理。</p>
<p>到这里，最基础的部分已经完成。接下来会探讨一些别的配置。</p>
<h2 id="pausesLocationUpdatesAutomatically属性"><a href="#pausesLocationUpdatesAutomatically属性" class="headerlink" title="pausesLocationUpdatesAutomatically属性"></a>pausesLocationUpdatesAutomatically属性</h2><p>贴上一段官网对这个属性的描述：</p>
<p>Allowing the location manager to pause updates can improve battery life on the target device without sacrificing location data. When this property is set to YES, the location manager pauses updates (and powers down the appropriate hardware) at times when the location data is unlikely to change. For example, if the user stops for food while using a navigation app, the location manager might pause updates for a period of time. You can help the determination of when to pause location updates by assigning a value to the activityTypeproperty.</p>
<p>大致的意思就是如果这个属性设置成YES（默认的也是YES），那么系统会检测如果设备有一段时间没有移动，就会自动停掉位置更新服务。<strong>这里需要注意的是，一旦定位服务停止了，只有当用户再次开启App的时候定位服务才会重新启动。</strong><br>这里的一段时间是系统自动判定的，可以通过设置activityTypeproperty这个属性来决定这个时间的长短。<br>API的意思是，类似导航类的App,系统检验的时间会稍长一点，想运动类的App，就会比导航类的短一点。但是具体时间还是由系统来决定。</p>
<h2 id="DeferredUpdates"><a href="#DeferredUpdates" class="headerlink" title="DeferredUpdates"></a>DeferredUpdates</h2><p>默认地，定位服务的代理会每秒钟都更新一次位置，这样对电池的消耗量会特别地大。除了设置pausesLocationUpdatesAutomatically这个属性以外，iOS还提供了DeferredUpdates的机制。</p>
<p>官方API文档：</p>
<pre><code>- (void)allowDeferredLocationUpdatesUntilTraveled:(CLLocationDistance)distance
                                      timeout:(NSTimeInterval)timeout
</code></pre><p>distance：<br>    The distance (in meters) from the current location that must be travelled before event delivery resumes. To specify an unlimited distance, pass the CLLocationDistanceMaxconstant.</p>
<p>timeout：<br>    The amount of time (in seconds) from the current time that must pass before event delivery resumes. To specify an unlimited amount of time, pass the CLTimeIntervalMax constant.</p>
<p>就是你可以设置让系统每隔多远或者每隔多长时间更新一次位置。注意是“或”的关系，满足一个就会更新。<br>使用这个方法有很多要注意的地方：</p>
<ol>
<li>desiredAccuracy必须设置成kCLLocationAccuracyBest</li>
<li>distanceFilter必须设置成kCLErrorDeferredDistanceFiltered</li>
<li>必须能够使用GPS进行定位（而不仅仅是移动数据或者Wi-Fi）</li>
<li><strong>非常重要的一点，DeferredUpdates只会出现在设备进入低耗电量的状态，App运行在前台或者设备连接在Xcode上正在调试是不会触发的。（所以不可能在Debug的时候打印Log来检验，要调试的话，需要写一些Log存在本地的数据库）</strong></li>
</ol>
<p>官网的Example：</p>
<pre><code>-(void)locationManager:(CLLocationManager *)manager
didUpdateLocations:(NSArray *)locations {
  // Add the new locations to the hike
  [self.hike addLocations:locations];

  // Defer updates until the user hikes a certain distance or a period of time has passed
  if (!self.deferringUpdates) {
    CLLocationDistance distance = self.hike.goal - self.hike.distance;
    NSTimeInterval time = [self.nextUpdate timeIntervalSinceNow];
    [self.locationManager allowDeferredLocationUpdatesUntilTraveled:distance timeout:time];
    self.deferringUpdates = YES;
  } }

-(void)locationManager:(CLLocationManager *)manager
    didFinishDeferredUpdatesWithError:(NSError *)error {
  // Stop deferring updates
  self.deferringUpdates = NO;

  // Adjust for the next goal
}
</code></pre><h2 id="反地理编码"><a href="#反地理编码" class="headerlink" title="反地理编码"></a>反地理编码</h2><p>知道了经纬度，有时候我们需要获取这个经纬度对应的详细地址信息，示例如下：</p>
<pre><code>CLGeocoder *revGeo = [[CLGeocoder alloc] init];
  [revGeo reverseGeocodeLocation:location
                 completionHandler:^(NSArray *placemarks, NSError *error) {
                     if (!error &amp;&amp; [placemarks count] &gt; 0)
                     {
                         NSDictionary *dict =
                         [[placemarks objectAtIndex:0] addressDictionary];
                         NSArray *formattedLines = [dict objectForKey:@&quot;FormattedAddressLines&quot;];
                         NSString *formattedAddress = formattedLines[0];
                         NSLog(@&quot;address is %@&quot;,formattedAddress);
                     }else{
                         NSLog(@&quot;ERROR: %@&quot;, error);
                     }
                 }];
</code></pre><h2 id="关于坐标系的问题"><a href="#关于坐标系的问题" class="headerlink" title="关于坐标系的问题"></a>关于坐标系的问题</h2><p>最后讲一下关于坐标系的问题。<br>世界通用的坐标系是WGS坐标系，中国国测局的坐标系是GCJ，百度有自己的坐标系。<br>同样的经纬度应用在不同的坐标系会有所偏差，在Github上面有一个库可以实现不同坐标系之间的转化：<br><a href="https://github.com/TinyQ/TQLocationConverter" target="_blank" rel="external">https://github.com/TinyQ/TQLocationConverter</a><br>系统返回的自然是根据WGS定位的。如果使用百度SDK获取的就是Baidu坐标系的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://noahli.com/2016/04/18/iOS-Core-Location/" data-id="cin5tbuby0001ahka8yctlcop" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Swift-Currying" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/18/Swift-Currying/" class="article-date">
  <time datetime="2016-04-18T03:34:26.000Z" itemprop="datePublished">2016-04-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/18/Swift-Currying/">Swift中的函数柯里化</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本博客主要是对以下博客的翻译，加入一些自己对使用的理解和总结<br><a href="https://robots.thoughtbot.com/introduction-to-function-currying-in-swift" target="_blank" rel="external">https://robots.thoughtbot.com/introduction-to-function-currying-in-swift</a></p>
<p>什么是函数柯里化：<br>在计算机科学中，柯里化（Currying）是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数的技术。</p>
<p>概念很抽象，让我们从一个简单的例子开始逐步了解到底什么是函数柯里化。<br>我们有一个接受两个Int类型的参数的Add函数</p>
<pre><code>func add(a: Int, b: Int) -&gt; Int {
  return a + b
}
</code></pre><p>当我们调用这个函数时：</p>
<pre><code>let sum = add(2, 3) // sum = 5
</code></pre><p>现在有一个需求，我们要将一个整数集合里面的每一个元素都加2.<br>那么我们可以这样写</p>
<pre><code>let xs = 1...100
let x = xs.map { add($0, 2) } // x = [3, 4, 5, 6, etc]
</code></pre><p>这样写看起来还行。但是我总觉得很奇怪。因为我要为Add这个函数创建一个闭包。<br>如果我们只关注函数的类型，就会发现Add实际上是一个(Int,Int)-&gt;Int的函数。但是在这里，我们想要传给map函数的，实际上是一个(A)-&gt;B的函数。</p>
<p>所以，如果我们有一个(A)-&gt;B这样的函数，那么我们就不必传入一个闭包，而是直接传这个函数就好了。所以我们可以这样：</p>
<pre><code>func addTwo(a: Int) -&gt; Int {
  return add(a, 2)
}

let xs = 1...100
let x = xs.map(addTwo) // x = [3, 4, 5, 6, etc]
</code></pre><p>但是这个函数其实把“2”写死了。那如果我还要+3，+4…+100呢？<br>所以我们最好写一个比较通用的函数。</p>
<pre><code>func add(a: Int) -&gt; (Int -&gt; Int) {
  return { b in a + b }
}
</code></pre><p>那么我们现在可以这样子用了：</p>
<pre><code>let sum = add(2)(3) // sum = 5

let addTwo = add(2)
let xs = 1...100
let x = xs.map(addTwo) // x = [3, 4, 5, 6, etc]
</code></pre><p>这个看起来已经不错了，但是我们通过泛型可以让这个函数更加通用一点。</p>
<pre><code>func curry&lt;A, B, C&gt;(f: (A, B) -&gt; C) -&gt; (A -&gt; (B -&gt; C)) {
  return { a: A in
            { b: B in
              return f(a, b) // returns C
            }
         }
}
</code></pre><p>在Swift中，可以最终简化成这样：</p>
<pre><code>func curry&lt;A, B, C&gt;(f: (A, B) -&gt; C) -&gt; A -&gt; B -&gt; C {
  return { a in { b in f(a, b) } }
}
</code></pre><p>那么讲了那么多，这东西有什么用呢？<br>假设有这样一个需求，我需要记录某个系统的日志，日志需要包含以下几个要素：<br>操作人的名字name，时间time，日志类型type和日志内容msg。<br>一般可能会写这样的函数来调用：</p>
<pre><code>func createLogInfo(name:String, time:String, type:String, msg:String) -&gt;String{
    return &quot;name : \(name)\n&quot; + &quot;type : \(time)\n&quot; + (&quot;message : \(msg)\n&quot; +&quot;time: \(time)    &quot;)
}

let log = createLogInfo(&quot;Noah&quot;, time: &quot;today&quot;, type: &quot;Info&quot;, msg: &quot;Today&apos;s weather is good&quot;)
</code></pre><p>现在我觉得每次都要传那么多参数很麻烦，对于我自己写的日志，我希望有一个简单一点的方法：</p>
<pre><code>func createMyLogInfo(time:String, type:String, msg:String) -&gt;String{
    return createLogInfo(&quot;Noah&quot;, time: time, type: type, msg: msg)
}
</code></pre><p>我希望有一个只写Info类型日志的方法来简化操作：</p>
<pre><code>func createInfoLog(name:String, time:String, msg:String) -&gt;String{
    return createLogInfo(name, time: time, type: &quot;Info&quot;, msg: msg)
}
</code></pre><p>这样我每次都要写一个函数来简化我的操作。<br>如果使用柯里化：</p>
<pre><code>func curryFour&lt;A,B,C,D,E&gt;(f:(A,B,C,D)-&gt;E) -&gt;A-&gt;B-&gt;C-&gt;D-&gt;E{
    return {
        a in {b in {c in {d in f(a,b,c,d) }}}
    }
}
let curriedLogInfo = curryFour(createLogInfo)
curriedLogInfo(&quot;Noah&quot;)(&quot;Today&quot;)(&quot;Error&quot;)(&quot;SometingWrong&quot;)
let curriedMyLog = curriedLogInfo(&quot;Noah&quot;)
curriedMyLog(&quot;Tmr&quot;)(&quot;Info&quot;)(&quot;SomeInfo&quot;)
let curriedMyTodayLog = curriedLogInfo(&quot;Noah&quot;)(&quot;Today&quot;)
curriedMyTodayLog(&quot;Warining&quot;)(&quot;FBI&quot;)
</code></pre><p>总结：<br>现在我们重新再来看一下柯里化的定义：<br>在计算机科学中，柯里化（Currying）是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数的技术。</p>
<p>关键点就在于能够把函数作为参数，并且可以把函数作为返回值来使用。<br>所以函数柯里化实际上应该是“函数作为一等公民”这个特性所带来的附加的属性。就像数学里面能够从公理推导出定理一样。<br>函数柯里化的作用，我现在感受到的主要是能够方便地把一些通用的函数通过柯里化这种技术变得更加地适用某些特殊的场景。<br>相对地，反柯里化就是将函数变得拥有更强的普适性。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://noahli.com/2016/04/18/Swift-Currying/" data-id="cin5tbubt0000ahkacffjqjla" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Swift/">Swift</a></li></ul>

    </footer>
  </div>
  
</article>


  

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Swift/">Swift</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/iOS/">iOS</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Swift/" style="font-size: 10px;">Swift</a> <a href="/tags/iOS/" style="font-size: 10px;">iOS</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">April 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/04/18/iOS-Core-Location/">iOS定位服务</a>
          </li>
        
          <li>
            <a href="/2016/04/18/Swift-Currying/">Swift中的函数柯里化</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 Noah Li<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>